#include <iostream>
#include <math.h>
#include <iomanip>
using namespace std;

double func1(double* x)
{
    return x[0] * x[0] * x[0] - x[1] * x[1] - 1;
}

double func1difx1(double* x)
{
    return 3 * x[0] * x[0];
}

double func1difx2(double* x)
{
    return  - 2 * x[1];
}

double func2(double* x)
{
    return x[0] * x[1] * x[1] * x[1] - x[1] - 4;
}

double func2difx1(double* x)
{
    return x[1] * x[1] * x[1];
}

double func2difx2(double* x)
{
    return 3 * x[0] * x[1] * x[1] - 1;
}

double f1der00(double* x, double dif) 
{
    x[0] += dif;
    double f = func1(x);
    x[0] -= dif;
    return f;
}
double f1der01(double* x, double dif)
{
    x[1] += dif;
    double f = func1(x);
    x[1] -= dif;
    return f;
}

double f2der10(double* x, double dif)
{
    x[0] += dif;
    double f = func2(x);
    x[0] -= dif;
    return f;
}
double f2der11(double* x, double dif)
{
    x[1] += dif;
    double f = func2(x);
    x[1] -= dif;
    return f;
}

void inverse_matrix(double** a)
{
    double det = a[0][0] * a[1][1] - a[0][1] * a[1][0];
    double  swep = a[0][0];
    a[0][0] = a[1][1];
    a[1][1] = swep;
    a[0][1] *= -1;
    a[1][0] *= -1;

    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            a[i][j] /= det;
}

void newton(double* sol, double** Jac)
{
    double e = 0.00001;

    while (abs(func1(sol)) > e && abs(func2(sol)) > e)
    {
        sol[0] -= (Jac[0][0] * func1(sol) + Jac[0][1] * func2(sol));
        sol[1] -= (Jac[1][0] * func1(sol) + Jac[1][1] * func2(sol));
        //cout << endl << "Текущие" << endl << "x1 = " << sol[0] << endl << "x2 = " << sol[1] << endl << endl;
    }
}


int main()
{
    setlocale(LC_ALL, "rus");
    double M = 0.05;
    double* sol = new double[2];
    sol[0] = 1.2; sol[1] = 1.3;

    cout << "Начальное приближение" << endl << "x1 = " << sol[0] << endl << "x2 = " << sol[1] << endl << endl;
    int n = 2;
    double** Jacobian = new double* [n];
    for (int i = 0; i < n; i++) 
    {
        Jacobian[i] = new double[n];
    }
    
    Jacobian[0][0] = func1difx1(sol);
    Jacobian[0][1] = func1difx2(sol);
    Jacobian[1][0] = func2difx1(sol);
    Jacobian[1][1] = func2difx2(sol);

    /* 
    Jacobian[0][0] = (f1der00(sol, M) - func1(sol)) / M;
    Jacobian[0][1] = (f1der01(sol, M) - func1(sol)) / M;
    Jacobian[1][0] = (f2der10(sol, M) - func2(sol)) / M;
    Jacobian[1][1] = (f2der11(sol, M) - func2(sol)) / M;
    */

    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            cout << Jacobian[i][j] << " ";
        }
        cout << endl;
    }
    inverse_matrix(Jacobian);

    cout << endl << "Обратная матрица Якоби" << endl;

    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            cout << Jacobian[i][j] << " ";
        }
        cout << endl;
    }

    newton(sol, Jacobian);

    cout << endl << "Результат" << endl << "x1 = " << sol[0] << endl << "x2 = " << sol[1] << endl << endl;

    for (int i = 0; i < n; i++)
    {
        delete[] Jacobian[i];
    }
    delete[] Jacobian;

}
